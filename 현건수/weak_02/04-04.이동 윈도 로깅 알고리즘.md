## 이동 윈도 로깅 알고리즘

> 앞서 살펴본 대로, 고정 윈도 카운터 알고리즘에는 중대한 문제가 있다. 윈도 경계 부근에 트래픽이 집중되는 경우 시스템에 설정된 한도보다 많은 요청을 처리하게 된다. 이동 윈도 로깅 알고리즘은 이 문제를 해결한다.
> 

### 동작 원리

- 요청의 `타임스탬프를 추적`한다. 타임스탬프 데이터는 보통 `레디스의 SortedSet` 같은 캐시에 보관한다.
- 새 요청이 오면 만료된 타임스탬프는 제거한다. 만료된 타임스탬프는 그 값이 현재 윈도의 시작 지점보다 오래된 스탬프를 말한다
- 새 요청의 타임스탬프를 로그에 추가한다.
- 로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달하고 그렇지 않으면 처리를 거부한다

<p align="center">
  <img src="https://user-images.githubusercontent.com/76584547/224108478-7905c727-38d0-4589-be11-98e8e579f1dc.png">
</p>


### 예제

- 분당 최대 2회의 요청
- 보통 로그에 기록되는 값은 리눅스 타임스탬프의 값

### 플로우

- 1:0030에 로그의 크기는 2이며 허용한도보다 크지 않아서 요청은 시스템에 전달된다.
- 새로운 요청이 1:00:50에 들어오면 로그의 크기는 3으로 로그에 남지만 요청은 거부된다
- 새로운 요청이 1:01:40에 들어오면 1:00:40 ~ 1:01:40 범위 안에 있는 요청은 1분 윈도 안에 있는 요청이지만, 1:00:40 이전의 타임스탬프틑 전부 만료된 값이다. 그렇기 때문에 1:00:01, 1:00:30을 삭제하고 삭제 직후의 로그는 2이므로 1:01:40의 신규 요청은 시스템에 전달된다.

### 장점

- 이 알고리즘은 처리율 메커니즘은 아주 정교하다. 어느 순간의 윈도를 보더라도, 허용되는 요청의 개수는 시스템의 처리율 한도를 넘지 않는다

### 단점

- 다량의 메모리 사용, 거부된 요청의 타임스탬프도 보관하기 때문에
